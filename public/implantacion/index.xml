<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Implantacions on Blog</title>
    <link>https://franjavimn.onrender.com/implantacion/</link>
    <description>Recent content in Implantacions on Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>es-ES</language>
    <copyright>Francisco Javier Martín Núñez</copyright>
    <lastBuildDate>Thu, 11 Feb 2021 14:17:18 +0100</lastBuildDate><atom:link href="https://franjavimn.onrender.com/implantacion/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Docker Compose</title>
      <link>https://franjavimn.onrender.com/implantacion/docker-compose/</link>
      <pubDate>Thu, 11 Feb 2021 14:17:18 +0100</pubDate>
      
      <guid>https://franjavimn.onrender.com/implantacion/docker-compose/</guid>
      <description>Docker Compose La herramienta Docker Compose, que nos permitirá definir y ejecutar múltiples aplicaciones utilizando contenedores de software.
Con Compose utilizaremos ficheros en formato YAML, que nos servirán para definir la configuración de la aplicación en cuestión. De esta manera podemos, con un solo comando, crear e iniciar los servicios configurados en estos ficheros.
Vamos a definir el escenario en un fichero llamado docker-compose.yaml y vamos a gestionar el ciclo de vida de la aplicaciones y de todos los contenedores que necesitamos con la utilidad docker-compose.</description>
    </item>
    
    <item>
      <title>Redes Docker</title>
      <link>https://franjavimn.onrender.com/implantacion/redes-docker/</link>
      <pubDate>Tue, 09 Feb 2021 13:22:13 +0100</pubDate>
      
      <guid>https://franjavimn.onrender.com/implantacion/redes-docker/</guid>
      <description>Redes en Docker Aunque hasta ahora no lo hemos tenido en cuenta, cada vez que creamos un contenedor, esté se conecta a una red virtual y docker hace una configuración del sistema (usando interfaces puente e iptables) para que la máquina tenga una ip interna, tenga acceso al exterior, podamos mapear (DNAT) puertos,…)
debian@omega:~$ docker run -it --rm debian bash -c &amp;#34;ip a&amp;#34; 1: lo: &amp;lt;LOOPBACK,UP,LOWER_UP&amp;gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.</description>
    </item>
    
    <item>
      <title>Almacenamiento Docker</title>
      <link>https://franjavimn.onrender.com/implantacion/almacenamiento-docker/</link>
      <pubDate>Tue, 09 Feb 2021 13:22:05 +0100</pubDate>
      
      <guid>https://franjavimn.onrender.com/implantacion/almacenamiento-docker/</guid>
      <description>Almacenamiento Los contenedores son efímeros, es decir, los ficheros, datos y configuraciones que creamos en los contenedores sobreviven a las paradas de los mismos pero, sin embargo, son destruidos si el contenedor es destruido.
Por lo que todo contenido que tengamos dentro del contenedor puede ser destruido y todo lo que haya en su interior, podemos verlo facilmente con el siguiente ejemplo de un servidor web:
#### Creamos el contenedor con la imagen de apache2 #### debian@omega:~$ docker run -d --name my-apache-app -p 8080:80 httpd:2.</description>
    </item>
    
    <item>
      <title>Introduccion Docker</title>
      <link>https://franjavimn.onrender.com/implantacion/introduccion-docker/</link>
      <pubDate>Mon, 01 Feb 2021 13:22:55 +0100</pubDate>
      
      <guid>https://franjavimn.onrender.com/implantacion/introduccion-docker/</guid>
      <description>Intrducción a Docker Docker es una tecnología de virtualización “ligera” cuyo elemento básico es la utilización de contenedores en vez de máquinas virtuales y cuyo objetivo principal es el despliegue de aplicaciones encapsuladas en dichos contenedores.
Docker está formado por varios componentes:
  Docker Engine: Es un demonio que corre sobre cualquier distribución de Linux y que expone una API externa para la gestión de imágenes y contenedores. Con ella podemos crear imágnenes, subirlas y bajarla de un registro de docker y ejecutar y gestionar contenedores.</description>
    </item>
    
    <item>
      <title>Cms Python</title>
      <link>https://franjavimn.onrender.com/implantacion/cms-python/</link>
      <pubDate>Fri, 22 Jan 2021 20:22:10 +0100</pubDate>
      
      <guid>https://franjavimn.onrender.com/implantacion/cms-python/</guid>
      <description>Instalación de aplicación web python En esta tarea vamos a desplegar un CMS python. Para ello he elegido de la pagina https://djangopackages.org/grids/g/cms/ el cms llamado Mezzanine y lo vamos a desplegar en el entorno de produccion con uwsgi.
Creacion en el entorno de desarrollo Lo primero que debemos de hacer es desplegar nuestra aplicacion en nuestro entorno de desarrollo para asi, mediante un repositorio en github, podamos llevarnos todo el despliegue a nuestra maquina en desarrollo, en este caso va a ser la maquina Quijote.</description>
    </item>
    
    <item>
      <title>Integracion Continua</title>
      <link>https://franjavimn.onrender.com/implantacion/integracion-continua/</link>
      <pubDate>Thu, 21 Jan 2021 17:34:08 +0100</pubDate>
      
      <guid>https://franjavimn.onrender.com/implantacion/integracion-continua/</guid>
      <description>Práctica: Introducción a la integración continua Debes realizar una de las siguientes tareas, utilizando una herramienta de CI/CD: GitHub Actions, GiLab CI/CD, CircleCI, Jenkins, … (No uses Travis CI).
En mi caso vamos a usar CodeShip, codeship es una plataforma alojada de integración y entrega continua. Se encuentra entre tu repositorio de código fuente (por ejemplo, GitHub, GitLab o Bitbucket) y el entorno de alojamiento (por ejemplo, Amazon Web Services) y prueba e implementa automáticamente cada cambio en tu plataforma.</description>
    </item>
    
    <item>
      <title>Instalar Guacamole</title>
      <link>https://franjavimn.onrender.com/implantacion/instalar-guacamole/</link>
      <pubDate>Wed, 30 Dec 2020 16:13:32 +0100</pubDate>
      
      <guid>https://franjavimn.onrender.com/implantacion/instalar-guacamole/</guid>
      <description>Instalcion de Guacamole En mi caso, en la practica sobre el despliegue de una aplicacion hecha en java con Tomcar vamos a elegir el cms llamado Guacamole.
¿Qué es Guacamole apache? Guacamole es un proyecto de escritorio remoto desarrollado por la Apache Software Foundation. Es un sistema compuesto por una parte cliente y una parte servidor. La aplicación servidor es la que se encarga de la autenticación y precisa de la instalación en infraestructura propia o acogerse la un servicio de terceros y estar accesible desde la parte cliente.</description>
    </item>
    
    <item>
      <title>Prueba Django</title>
      <link>https://franjavimn.onrender.com/implantacion/prueba-django/</link>
      <pubDate>Thu, 10 Dec 2020 14:08:25 +0100</pubDate>
      
      <guid>https://franjavimn.onrender.com/implantacion/prueba-django/</guid>
      <description>Despliegue de aplicaciones python Tarea 1 Entorno de desarrollo Vamos a desarrollar la aplicación del tutorial de django 3.1. Vamos a configurar tu equipo como entorno de desarrollo para trabajar con la aplicación, para ello:
 Vamos a desarrollar la aplicación del tutorial de django 3.1. Vamos a configurar tu equipo como entorno de desarrollo para trabajar con la aplicación, para ello: https://github.com/josedom24/django_tutorial.  Por lo que nos vamos a ese repositorio y lo que vamos a hacer es crear un fork a nuestro repositorio para posteriormente clonarlo en nuestra maquina:</description>
    </item>
    
    <item>
      <title>Instalacion Nginx Ovh</title>
      <link>https://franjavimn.onrender.com/implantacion/instalacion-nginx-ovh/</link>
      <pubDate>Wed, 18 Nov 2020 18:21:55 +0100</pubDate>
      
      <guid>https://franjavimn.onrender.com/implantacion/instalacion-nginx-ovh/</guid>
      <description>Realizar la migración de la aplicación drupal que tienes instalada en el entorno de desarrollo a nuestro entorno de producción, para ello ten en cuenta lo siguiente: Tarea 1 La aplicación se tendrá que migrar a un nuevo virtualhost al que se accederá con el nombre portal.iesgn13.es.
De esta forma ya tenemos listo nuestro documentroot para nuestro nuevo virtualhost, ahora el siguiente paso es crear dicho virtualhost, para ello seguimos los pasos siguientes:</description>
    </item>
    
    <item>
      <title>Practica Cms</title>
      <link>https://franjavimn.onrender.com/implantacion/practica-cms/</link>
      <pubDate>Fri, 30 Oct 2020 18:03:23 +0100</pubDate>
      
      <guid>https://franjavimn.onrender.com/implantacion/practica-cms/</guid>
      <description>Instalación local de un CMS PHP Esta tarea consiste en instalar un CMS de tecnología PHP en un servidor local. Los pasos que tendrás que dar los siguientes:
Tarea 1: Instalación de un servidor LAMP   Crear una instancia de vagrant basado en un box debian o ubuntu
  Instala en esa máquina virtual toda la pila LAMP
  Tarea 2: Instalación de drupal en mi servidor local   Configura el servidor web con virtual hosting para que el CMS sea accesible desde la dirección: www.</description>
    </item>
    
    <item>
      <title>Guia Hugo</title>
      <link>https://franjavimn.onrender.com/implantacion/guia-hugo/</link>
      <pubDate>Wed, 14 Oct 2020 17:15:19 +0200</pubDate>
      
      <guid>https://franjavimn.onrender.com/implantacion/guia-hugo/</guid>
      <description>GoHugo ¿Que es GoHugo? Hugo es un generador de sitio estático escrito en Go. Hugo ha visto un gran aumento en las características y el rendimiento gracias al desarrollador principal actual Bjørn Erik Pedersen y otros colaboradores. Hugo es de codigo abierto bajo la licencia de Apache License 2.0.
Al ser capaz de generar la mayoría de los sitios web en segundos (a &amp;lt;1 ms por página), Hugo es reconocido como &amp;ldquo;el framework más rápido del mundo para la creación de sitios web&amp;rdquo; gracias no solo a que se ha creado con Go, sino también a los esfuerzos concienzudos de sus desarrolladores para comparar y aumentar actuación.</description>
    </item>
    
  </channel>
</rss>
